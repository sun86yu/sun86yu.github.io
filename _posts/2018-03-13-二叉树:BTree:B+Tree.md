---
layout: post
book: true
background-image: http://ot1cc1u9t.bkt.clouddn.com/17-7-16/91630214.jpg
category: 算法/数据结构
title: 二叉树/B-Tree/B+Tree
tags:
- B-Tree
---

二叉查找树
===
不同于数组、链表、哈希表等其它数据存储结构的一种结构。对于其中的每个节点，左子节点的值都比它 小，而右子节点的值都比它大。

如下图:

![](/images/tree/tree_01.png)

如果要查找 5，要先找到根节点 6。由于 6 比 5 小，所以要往左边的分支找。找到了 3，3 比 5 小，于是要再往右边的分支找。这样就找到了 5。

可以看到，在二叉树里查找一个值是很快的，和二分法差不多的效率。它的平均查找时间是 O(log n)，在最坏的情况下是 O(n)；在有序的数组中查找时，最坏的情况下也只要 O(log n)，但二叉树的插入和删除要比数据快得多。时间表示如下：

![](/images/tree/tree_02.png)

当然，二叉树有个明显的缺陷就是不能进行随机访问，比如：第 5 个元素是什么？

二叉树的根节点可以是任意的一个值，比如同样是上面的 2 - 8 几个数字，也可以如下构造：

![](/images/tree/tree_03.png)

但如果我们要查找 8，它就得经过 2，3，5，7，最后找到 8。但在前面的结构中，只需要经过 6，7，8。所以这样的树结构性能就比较差。在应用中，我们如果要让树效率高，就要让树***“平衡”***。

平衡二叉树（AVL Tree）
===
平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差<=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1:

![](/images/tree/tree_04.png)

如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。它们的示意图如下： 

![](/images/tree/tree_05.png)

![](/images/tree/tree_06.png)

这四种失去平衡的姿态都有各自的定义： 

1. LL：LeftLeft，也称“左左”。插入或删除一个节点后，根节点的左孩子（Left Child）的左孩子（Left Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。

2. RR：RightRight，也称“右右”。插入或删除一个节点后，根节点的右孩子（Right Child）的右孩子（Right Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。

3. LR：LeftRight，也称“左右”。插入或删除一个节点后，根节点的左孩子（Left Child）的右孩子（Right Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。

4. RL：RightLeft，也称“右左”。插入或删除一个节点后，根节点的右孩子（Right Child）的左孩子（Left Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。

AVL树失去平衡之后，可以通过旋转使其恢复平衡。下面分别介绍四种失去平衡的情况下对应的旋转方法。

___LL的旋转___

LL失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡。步骤如下：

1. 将根节点的左孩子作为新根节点。
2. 将新根节点的右孩子作为原根节点的左孩子。
3. 将原根节点作为新根节点的右孩子。

图示如下：
![](/images/tree/tree_07.png)

___RR的旋转___

RR失去平衡的情况下，旋转方法与LL旋转对称，步骤如下：

1. 将根节点的右孩子作为新根节点。
2. 将新根节点的左孩子作为原根节点的右孩子。
3. 将原根节点作为新根节点的左孩子。

图示如下：
![](/images/tree/tree_08.png)

___LR的旋转___

LR失去平衡的情况下，需要进行两次旋转，步骤如下：

1. 围绕根节点的左孩子进行RR旋转。
2. 围绕根节点进行LL旋转。

图示如下：
![](/images/tree/tree_09.png)

![](/images/tree/tree_10.png)

___RL的旋转___

RL失去平衡的情况下也需要进行两次旋转，旋转方法与LR旋转对称，步骤如下：

1. 围绕根节点的右孩子进行LL旋转。
2. 围绕根节点进行RR旋转。

图示如下：
![](/images/tree/tree_11.png)

![](/images/tree/tree_12.png)

平衡多路查找树（B-Tree）
===
B-Tree是为磁盘等外存储设备设计的一种平衡查找树。

系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。

InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：

```
mysql> show variables like 'innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.01 sec)

```

而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。

InnoDB在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。

为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

一个 m 阶的B-Tree有如下特性
---

1. 每个节点最多有 m 个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有 Ceil(m / 2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0, P1, … Pn, k1, …kn） 
6. 关键字的个数 n 满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

如图有一个三阶 B-Tree：
![](/images/tree/tree_13.png)

每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字(ceil(3/2)-1<=n<=3-1)和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。

两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

***模拟查找关键字29的过程：***

1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29。

需要3次磁盘I/O操作，和3次内存查找操作就可以找到了。

B-Tree相对于AVLTree缩减了节点个数，它一个节点存入了更多的数据。使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。

B+Tree
===
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用B+Tree实现其索引结构。

B-Tree 的结构中，各个节点不仅包括了 key 的值，还包括了 data 的值。而每一页的空间是有限的，所以注定保存不了多少节点。这样就会导致树的深度会特别大，增大磁盘I/O的次数，影响查询效率。

>在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

***所以，B+Tree相对于B-Tree有几点不同：***

1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。

将前面的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 

![](/images/tree/tree_14.png)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用32位,4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。

>辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。